# 算法实践题目

## 一、第一部分 基础 🆗

### 1. POJ 1000 A + B 🆗

- **简述**

  &emsp;&emsp;基础题目，熟悉 POJ 平台的提交等操作。

- **代码**

```c++
//Memory: 96k
//Time:   0ms
//Result: Accepted
#include <cstdio>
using namespace std;

int main() {
    int a, b;
    scanf("%d %d", &a, &b);
    printf("%d\n", a + b);
    return 0;
}
```

- **分析**

  &emsp;&emsp;无

### 2. POJ 1005 I Think I Need a HouseBoat 🆗

- **简述**

  &emsp;&emsp;密西西比河岸某处陆地因为河水侵蚀，每年陆地面积都在减少，每年减少 50 平方英里，
  减少的陆地面积呈半圆形，即该半圆形面积以每年 50 平方英里的速度增长。在第一年初时，
  该半圆形面积为 0，半圆形的圆心坐标为（0,0），现在的任务是给定一个坐标，求出该坐标
  在哪一年年底会被河水侵蚀。假设给定的坐标到圆心的距离不会等于半圆的半径。

- **格式**

  - **输入**

    &emsp;&emsp;第一行输入坐标个数，第二行开始输入坐标，每个坐标占一行，每个坐标由横坐标和纵
    坐标组成，坐标值为浮点数，单位为英里。

  - **输出**

    &emsp;&emsp;输出该坐标会在哪一年年底开始被河水侵蚀。对应每个坐标输出一行，输出结束后输
    出 “END OF OUTPUT.”

- **代码**

```c++
//Memory: 124k
//Time:   0ms
//Result: Accepted
#include <cmath>
#include <cstdio>
#define PI 3.1415926535
#define SQR(x) ((x) * (x))

int n;
double x, y;

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%lf %lf", &x, &y);
        int res = ceil(PI * (SQR(x) + SQR(y)) / 100.0);
        printf("Property %d: This property will begin eroding in year %d.\n", i, res);
    }
    printf("END OF OUTPUT.");
    return 0;
}
```



### 3. POJ 1753 Flip Game 🆗

- **简述**

  &emsp;&emsp;有 $4 \times 4$ 的正方形，每个格子要么是黑色，要么是白色，当把一个格子的颜色改变（黑->
  白或者白->黑）时，其周围上下左右（如果存在的话）的格子的颜色也被反转，问至少反转几
  个格子可以使 $4 \times 4$ 的正方形变为纯白或者纯黑？ 

- **格式**

  - **输入**

    &emsp;&emsp;四行，每行四个字符，为 w 或 b，分别代表白色和黑色。

  - **输出**

    &emsp;&emsp;一个数字，为最少反转次数。

- **代码**

```c++
//Memory: 96k
//Time:   141ms
//Result: Accepted
#include <algorithm>
#include <climits>
#include <cstdio>
using namespace std;

const int dir[] = {-1, 0, 1, 0, -1};
char board[5][5];

void change(int x, int y) {
    board[x][y] = (board[x][y] == 'b') ? 'w' : 'b';
    for (int i = 0; i < 4; i++) {
        int dx = x + dir[i], dy = y + dir[i + 1];
        if (dx < 0 || dx >= 4 || dy < 0 || dy >= 4) continue;
        board[dx][dy] = (board[dx][dy] == 'b') ? 'w' : 'b';
    }
}

bool check() {
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++)
            if (board[i][j] != board[0][0]) return false;
    }
    return true;
}

int minStep = 100;

void dfs(int x, int y, int cur) {
    if (check()) {
        minStep = min(minStep, cur);
        return;
    }
    if (x == 4) return;
    if (y == 3) {
        dfs(x + 1, 0, cur);
        change(x, y);
        dfs(x + 1, 0, cur + 1);
        change(x, y);
    } else {
        dfs(x, y + 1, cur);
        change(x, y);
        dfs(x, y + 1, cur + 1);
        change(x, y);
    }
}

int main() {
    for (int i = 0; i < 4; i++)
        scanf("%s", board[i]);
    dfs(0, 0, 0);
    if (minStep <= 16) printf("%d\n", minStep);
    else
        printf("Impossible\n");
    return 0;
}
```



### 4. POJ 3295 Tautology 🆗

- **简述**

  &emsp;&emsp;输入由 p、q、r、s、t、K、A、N、C、E 共 10 个字母组成的逻辑表达式，其中 p、q、r、s、t 的值为 1（true）或 0（false），即逻辑变量；K、A、N、C、E 为逻辑运算符， 

  - K --> and： `x && y`
  - A --> or：`x || y `
  - N --> not ： `!x `
  - C --> implies： `(!x) || y`
  - E --> equals： `x == y `

  &emsp;&emsp;问这个逻辑表达式是否为永真式。输入格式保证是合法的。

- **格式**

  - **输入**

    &emsp;&emsp;输入包括多组测试，每组测试为一行逻辑表达式（不超过 100 个字符），最后一行以 0 为结束标志。

  - **输出**

    &emsp;&emsp;重言式输出 tautology，否则输出 not。

- **代码**

```c++
//Memory: 108k
//Times:  16ms
//Result: Accepted
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <stack>
#define K(a, b) ((a) && (b))
#define A(a, b) ((a) || (b))
#define N(a) (!(a))
#define C(a, b) (!(a) || (b))
#define E(a, b) ((a) == (b))
using namespace std;
const int maxn = 100 + 1;

char expression[maxn];

bool solve() {
    stack<int> stk;
    int len = strlen(expression), x1, x2;
    for (int p = 0; p < 2; p++) {
        for (int q = 0; q < 2; q++) {
            for (int r = 0; r < 2; r++) {
                for (int s = 0; s < 2; s++) {
                    for (int t = 0; t < 2; t++) {
                        for (int i = len - 1; i >= 0; i--) {
                            switch (expression[i]) {
                                //遇到变量
                                case 'p':
                                    stk.push(p);
                                    break;
                                case 'q':
                                    stk.push(q);
                                    break;
                                case 'r':
                                    stk.push(r);
                                    break;
                                case 's':
                                    stk.push(s);
                                    break;
                                case 't':
                                    stk.push(t);
                                    break;
                                //遇到表达式
                                case 'N'://唯一的一元运算
                                    x1 = stk.top(), stk.pop();
                                    stk.push(N(x1));
                                    break;
                                default://其余的二元运算
                                    x1 = stk.top(), stk.pop();
                                    x2 = stk.top(), stk.pop();
                                    if (expression[i] == 'K')
                                        stk.push(K(x1, x2));
                                    else if (expression[i] == 'A')
                                        stk.push(A(x1, x2));
                                    else if (expression[i] == 'C')
                                        stk.push(C(x1, x2));
                                    else
                                        stk.push(E(x1, x2));
                                    break;
                            }
                        }
                        x1 = stk.top(), stk.pop();
                        if (!x1) return false;
                    }
                }
            }
        }
    }
    return true;
}

int main() {
    while (scanf("%s", expression) && expression[0] != '0') {
        (solve()) ? printf("tautology\n") : printf("not\n");
    }
    return 0;
}
```



## 二、第二部分 分治 🆗

### 5. POJ 2366 Sacrament of the sum 🆗

- **代码**

```c++
#include <algorithm>
#include <cstdio>
using namespace std;
const int maxn = 50000 + 5;

int A[maxn], B[maxn];
int aLen, bLen;

int main() {
    scanf("%d", &aLen);
    for (int i = 0; i < aLen; i++) scanf("%d", &A[i]);
    scanf("%d", &bLen);
    for (int i = 0; i < bLen; i++) scanf("%d", &B[i]);
    for (int i = 0; i < bLen; i++) {
        int target = 10000 - B[i];
        if (binary_search(A, A + aLen, target)) {
            printf("YES\n");
            return 0;
        }
    }
    printf("NO\n");
    return 0;
}
```



### 6. POJ 2503 Babelfish 🆗

- **代码**

```c++
#include <cstdio>
#include <iostream>
#include <map>
#include <string>
using namespace std;

map<string, string> dict;
char English[11], French[11], tmp[30];

int main() {
    while (fgets(tmp, sizeof(tmp), stdin)) {
        if (tmp[0] == '\n') break;
        sscanf(tmp, "%s %s", English, French);
        dict[string(French)] = string(English);
    }
    while (scanf("%s", tmp) == 1) {
        if (dict.count(tmp))
            cout << dict[string(tmp)] << endl;
        else
            cout << "eh" << endl;
    }
    return 0;
}
```



### 7. POJ 3714 Raid 🆗

- **代码**

```c++
#include <algorithm>
#include <climits>
#include <cmath>
#include <cstdio>
#define LL long long
#define SQR(x) ((x) * (x))
using namespace std;
const LL INF = LLONG_MAX;
const int maxn = 100000 + 5;

enum Kind { Agent, Station };

int n, T;
LL x, y;

struct node {
    int kind;
    LL x, y;
    node(int id = 0, LL x = 0, LL y = 0) : kind(id), x(x), y(y) {}
    bool operator<(const node &a) const {
        return x == a.x ? y < a.y : x < a.x;
    }
};

node a[maxn << 1];

inline double getDis(const node &a, const node &b) {
    return sqrt((double) SQR(a.x - b.x) + (double) SQR(a.y - b.y));
}

double solve(int left, int right) {
    if (left == right) return INF;
    int mid = left + ((right - left) >> 1);
    double dis = min(solve(left, mid), solve(mid + 1, right));
    for (int i = mid; i >= left; i--) {
        if (a[mid].x - a[i].x > dis) break;
        for (int j = mid + 1; j <= right; j++) {
            if (a[j].x - a[i].x > dis) break;
            if (a[i].kind != a[j].kind) {
                double tmp = getDis(a[i], a[j]);
                dis = min(dis, tmp);
            }
        }
    }
    return dis;
}

int main() {
    scanf("%d", &T);
    while (T--) {
        scanf("%d", &n);
        for (int i = 0; i < n; i++) {
            scanf("%lld %lld", &x, &y);
            a[i] = node(Station, x, y);
        }
        for (int i = n; i < (n << 1); i++) {
            scanf("%lld %lld", &x, &y);
            a[i] = node(Agent, x, y);
        }
        sort(a, a + (n << 1));
        printf("%.3f\n", solve(0, (n << 1) - 1));
    }
    return 0;
}
```



### 8. POJ 3233 Matrix Power Series 🆗 🆗 :small_orange_diamond:

- **代码（base）**

```c++
//Memory: 988k
//Time:   1485ms
//Result: Accepted
#include <cstdio>
#include <cstring>
using namespace std;
const int maxn = 30 + 5;

int n, k, m;

struct matrix {
    int mat[maxn][maxn];
};

matrix a, res;

matrix matMulti(matrix a, matrix b) {
    matrix c;
    memset(c.mat, 0, sizeof(c.mat));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            for (int k = 0; k < n; k++)
                c.mat[i][j] = (c.mat[i][j] + (a.mat[i][k] * b.mat[k][j]) % m) % m;
        }
    }
    return c;
}

matrix matPow(matrix a, int k) {
    matrix s;
    memset(s.mat, 0, sizeof(s.mat));
    for (int i = 0; i < n; i++) s.mat[i][i] = 1;
    while (k) {
        if (k & 1) s = matMulti(s, a);
        a = matMulti(a, a);
        k >>= 1;
    }
    return s;
}

matrix matAdd(matrix a, matrix b) {
    matrix s;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++)
            s.mat[i][j] = (a.mat[i][j] + b.mat[i][j]) % m;
    }
    return s;
}

matrix solve(matrix a, int k) {
    matrix s, b;
    if (k == 1) return a;
    s = solve(a, k >> 1);
    if (k & 1) {
        b = matPow(a, k / 2 + 1);
        s = matAdd(matMulti(b, s), s);
        return matAdd(s, b);
    } else {
        b = matPow(a, k >> 1);
        return matAdd(matMulti(b, s), s);
    }
}

int main() {
    scanf("%d %d %d", &n, &k, &m);
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            scanf("%d", &a.mat[i][j]);
            a.mat[i][j] %= m;
        }
    }
    res = solve(a, k);
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            printf("%d", res.mat[i][j]);
            if (j != n - 1) putchar(' ');
        }
        putchar('\n');
    }
    return 0;
}
```

- **代码（enhanced）**

```c++
//Memory: 156k
//Time:   844ms
//Result: Accepted
#include <cstdio>
#include <cstring>
const int maxn = 30 + 5;
const int dmaxn = maxn << 1;

int n, k, m;

int a[dmaxn][dmaxn], b[dmaxn][dmaxn], c[dmaxn][dmaxn];

void matMulti(int a[dmaxn][dmaxn], int b[dmaxn][dmaxn]) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            c[i][j] = 0;
            for (int k = 0; k < n; k++)
                c[i][j] = (c[i][j] + (a[i][k] * b[k][j]) % m) % m;
        }
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++)
            a[i][j] = c[i][j];
    }
}

int main() {
    scanf("%d %d %d", &n, &k, &m);
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            scanf("%d", &a[i][j]);
        }
        a[i][i + n] = a[i + n][i + n] = b[i][i] = b[i + n][i + n] = 1;
    }
    n <<= 1;
    k++;
    while (k) {
        if (k & 1) matMulti(b, a);
        k >>= 1;
        matMulti(a, a);
    }
    n >>= 1;
    for (int i = 0; i < n; i++) b[i][i + n]--;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            printf("%d", b[i][j + n] < 0 ? b[i][j + n] + m : b[i][j + n]);
            if (j != n - 1) putchar(' ');
        }
        putchar('\n');
    }
    return 0;
}
```

- **代码（cache friendly）**

```c++
```



### 选做 POJ 2506 Tiling 🆗

- **代码**

```c++
//Memory: 164k
//Time:   0ms
//Result: Accepted
#include <cstdio>
#include <iostream>
#include <string>
using namespace std;
const int maxn = 250 + 5;

string a[maxn];
int n;

string strAdd(string x, string y) {
    if (x.length() < y.length()) return strAdd(y, x);
    for (int i = x.length() - 1, j = y.length() - 1; i >= 0; i--, j--) {
        if (j >= 0) x[i] += y[j] - '0';
        if (x[i] - '0' >= 10) {
            x[i] = (x[i] - '0') % 10 + '0';
            if (i > 0)
                x[i - 1]++;
            else
                x = "1" + x;
        }
    }
    return x;
}

int main() {
    a[0] = "1", a[1] = "1", a[2] = "3";
    for (int i = 3; i <= 250; i++)
        a[i] = strAdd(strAdd(a[i - 1], a[i - 2]), a[i - 2]);
    while (scanf("%d", &n) != EOF) cout << a[n] << endl;
    return 0;
}
```



## 三、第三部分 二分 + 中位数（删除） 🆗

### 9. POJ 1723 SOLDIERS 🆗 🆗

- **简述**

- **分析**

  引理：在一个长为 $n$ 的序列 $a$ 中找一个数 $a_k$，使得 $\sum\limits_{i=1}^n \abs{a_i-a_k}$ 最小，则 $a_k$ 为 $a$ 的中位数。

- **代码 PRE**

```c++
//Memory: 176k
//Time:   0ms
//Result: Accepted
#include <algorithm>
#include <cstdio>
#define LL long long
using namespace std;
const int MAXN = 10000 + 5;

int n;
int X[MAXN], Y[MAXN];
LL res;

int main() {
    // freopen("./DATA/in.txt", "r", stdin);
    scanf("%d", &n);
    for (int i = 0; i < n; i++)
        scanf("%d %d", &X[i], &Y[i]);
    sort(X, X + n), sort(Y, Y + n);
    for (int i = 0; i < n; i++) X[i] -= i;
    sort(X, X + n);
    for (int i = 0; i < n; i++)
        res += abs(X[i] - X[n >> 1]) + abs(Y[i] - Y[n >> 1]);
    printf("%lld\n", res);
    return 0;
}
```

- **代码 AFTER**

```c++
//Memory: 320k
//Time:   141ms
//Result: Accepted
#include <algorithm>
#include <cstdio>
using namespace std;
const int MAXN = 10000 + 5;

int n;
int X[MAXN], Y[MAXN];

//划分操作。
int Partition(int *a, int left, int right) {
    int pivot = a[left], pos = left;
    for (int i = left + 1; i <= right; i++)
        if (a[i] < pivot) swap(a[++pos], a[i]);
    swap(a[left], a[pos]);
    return pos;
}

//寻找第 k 小数。
int FindKMin(int *a, int k, int left, int right) {
    int pos = Partition(a, left, right);
    int cnt = pos - left + 1;
    if (left == right) return a[left];
    if (k == cnt) return a[pos];
    return k > cnt ? FindKMin(a, k - cnt, pos + 1, right) : FindKMin(a, k, left, pos - 1);
}

//基于快速排序的中位数查找算法，时间复杂度 O(n)。数组下标从 1 开始。
int FindMedian(int a[], int len) {
    if (len & 1) {
        return FindKMin(a, (len >> 1) + 1, 1, len);
    } else {
        return (FindKMin(a, len >> 1, 1, len) + FindKMin(a, (len >> 1) + 1, 1, len)) >> 1;
    }
}

long long res;

int main() {
    // freopen("./DATA/in.txt", "r", stdin);
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        scanf("%d %d", &X[i], &Y[i]);
    int yMedian = FindMedian(Y, n);
    sort(X + 1, X + 1 + n);
    for (int i = 1; i <= n; i++) X[i] -= i;
    int xMedian = FindMedian(X, n);
    for (int i = 1; i <= n; i++)
        res += abs(X[i] - xMedian) + abs(Y[i] - yMedian);
    printf("%lld\n", res);
    return 0;
}
```



### 10. POJ 3269 Building A New Barn 🆗

- 代码

```c++
//Memory: 280k
//Time:   47ms
//Result: Accepted
#include <algorithm>
#include <cstdio>
using namespace std;
const int MAXN = 10000 + 5, INF = 0x7fffffff;
const int dir[] = {-1, 0, 1, 0, -1};

int n;
int X[MAXN], Y[MAXN];

struct point {
    int x, y;
};

point cows[MAXN];

int ManhattanSum(int xx, int yy) {
    int res = 0;
    for (int i = 1; i <= n; i++)
        res += abs(X[i] - xx) + abs(Y[i] - yy);
    return res;
}

int res1 = INF, res2;

int main() {
    // freopen("./DATA/in.txt", "r", stdin);
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        scanf("%d %d", &X[i], &Y[i]), cows[i].x = X[i], cows[i].y = Y[i];
    sort(X + 1, X + 1 + n), sort(Y + 1, Y + 1 + n);
    if (n & 1) {
        int xMedian = X[(n >> 1) + 1], yMedian = Y[(n >> 1) + 1];
        for (int k = 0; k < 4; k++) {
            int dx = xMedian + dir[k], dy = yMedian + dir[k + 1];
            int sum = ManhattanSum(dx, dy);
            if (sum < res1) res1 = sum, res2 = 1;
            else if (sum == res1)
                res2++;
        }
    } else {
        int xMedian1 = X[(n >> 1) + 1], xMedian2 = X[n >> 1], yMedian1 = Y[(n >> 1) + 1], yMedian2 = Y[n >> 1];
        res2 = (xMedian1 - xMedian2 + 1) * (yMedian1 - yMedian2 + 1);
        res1 = ManhattanSum(xMedian1, yMedian1);
        for (int i = 1; i <= n; i++)
            if (cows[i].x <= xMedian1 && cows[i].x >= xMedian2 && cows[i].y <= yMedian1 && cows[i].y >= yMedian2)
                res2--;
    }
    printf("%d %d\n", res1, res2);
    return 0;
}
```



### 11. POJ 3579 Median 🆗

- **代码**

```c++
//Memory: 256k
//Time:   594ms
//Result: Accepted
#include <algorithm>
#include <cstdio>
#define LL long long
using namespace std;
const int MAXN = 100000 + 5;

int T, n;
LL m;
int a[MAXN];

bool check(int x) {
    LL sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += upper_bound(a + 1, a + 1 + n, a[i] + x) - a - i - 1;
        if (sum >= m) return true;
    }
    return false;
}

int main() {
    // freopen("./DATA/in.txt", "r", stdin);
    while (scanf("%d", &n) == 1) {
        m = (LL) (n * (n - 1) / 2 + 1) / 2;
        for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
        sort(a + 1, a + 1 + n);
        int left = 0, right = a[n];
        while (left < right) {
            int mid = left + ((right - left) >> 1);
            check(mid) ? right = mid : left = mid + 1;
        }
        printf("%d\n", left);
    }
    return 0;
}
```



## 四、第四部分 动态规划 🆗

### 12. POJ 1050 To the Max 🆗

- **代码**

```c++
#include <algorithm>
#include <climits>
#include <cstdio>
using namespace std;
const int maxn = 100 + 5;

int n;
int a[maxn][maxn];
int dp[maxn][maxn];

int main() {
    scanf("%d", &n);
    //读入数据
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++)
            scanf("%d", &a[i][j]);
    }
    //构建二维前缀和
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++)
            dp[i][j] = dp[i][j - 1] + dp[i - 1][j] - dp[i - 1][j - 1] + a[i][j];
    }
    int res = INT_MIN;
    //遍历，求解最大值
    for (int x1 = 1; x1 <= n; x1++) {
        for (int y1 = 1; y1 <= n; y1++) {
            for (int x2 = x1; x2 <= n; x2++) {
                for (int y2 = y1; y2 <= n; y2++)
                    res = max(res, dp[x2][y2] - dp[x1 - 1][y2] - dp[x2][y1 - 1] + dp[x1 - 1][y1 - 1]);
            }
        }
    }
    printf("%d\n", res);
    return 0;
}
```



### 13. POJ 1088 滑雪 🆗

- **代码**

```c++
#include <cstdio>
#include <algorithm>
using namespace std;
const int maxn = 100 + 5;
const int dir[] = {-1, 0, 1, 0, -1};

int R, C;
int a[maxn][maxn];
int dp[maxn][maxn];

int dfs(int x, int y) {
    if (dp[x][y]) return dp[x][y];
    dp[x][y] = 1;
    for (int k = 0; k < 4; k++) {
        int dx = x + dir[k], dy = y + dir[k + 1];
        if (dx < 1 || dx > R || dy < 1 || dy > C || a[dx][dy] <= a[x][y]) continue;
        dfs(dx, dy);
        dp[x][y] = max(dp[x][y], dp[dx][dy] + 1);
    }
    return dp[x][y];
}

int main() {
    scanf("%d %d", &R, &C);
    //读入数据
    for (int i = 1; i <= R; i++) {
        for (int j = 1; j <= C; j++)
            scanf("%d", &a[i][j]);
    }
    int res = 0;
    for (int i = 1; i <= R; i++) {
        for (int j = 1; j <= C; j++)
            res = max(res, dfs(i, j));
    }
    printf("%d\n", res);
    return 0;
}
```



### 14. POJ 1185 炮兵阵地 🆗 :small_orange_diamond:

- **代码**

```c++
#include <cstdio>
#include <algorithm>
using namespace std;
const int maxn = 100 + 1;
const int maxm = 10 + 1;

int n, m, res;
int dp[1 << 10][1 << 10][3];//dp[last][cur][i]：上一行状态 last，当前行状态 cur，处理到了第 i 行
int a[maxn];
int sum[1 << 10];

int countOne(int status) {
    int cnt = 0;
    while (status) {
        if (status & 1) cnt++;
        status >>= 1;
    }
    return cnt;
}

char tmp[maxn];

int main() {
    scanf("%d %d", &n, &m);
    for (int i = 0; i < n; i++) {
        scanf("%s", tmp);
        for (int j = 0; j < m; j++) {
            a[i] <<= 1, a[i] += tmp[j] == 'H' ? 1 : 0;
        }
    }
    for (int i = 0; i < (1 << m); i++) sum[i] = countOne(i);
    for (int cur = 0; cur < (1 << m); cur++) {
        if ((cur & a[0]) || (cur & (cur << 1)) || (cur & (cur << 2))) continue;//不合法的状态
        dp[0][cur][0] = sum[cur];
    }
    for (int last = 0; last < (1 << m); last++) {
        for (int cur = 0; cur < (1 << m); cur++) {
            if ((last & cur) || (last & a[0]) || (last & (last << 1)) || (last & (last << 2)) || (cur & a[1]) || (cur & (cur << 1)) || (cur & (cur << 2))) continue;
            dp[last][cur][1] = sum[last] + sum[cur];
        }
    }
    for (int i = 2; i < n; i++) {
        for (int last = 0; last < (1 << m); last++) {
            if ((last & a[i - 1]) || (last & (last << 1)) || (last & (last << 2))) continue;
            for (int cur = 0; cur < (1 << m); cur++) {
                if ((last & cur) || (cur & a[i]) || (cur & (cur << 1)) || (cur & (cur << 2))) continue;
                for (int llast = 0; llast < (1 << m); llast++) {
                    if ((llast & last) || (llast & cur) || (llast & a[i - 2]) || (llast & (llast << 1)) || (llast & (llast << 2))) continue;
                    dp[last][cur][i % 3] = max(dp[last][cur][i % 3], dp[llast][last][(i - 1) % 3] + sum[cur]);
                }
            }
        }
    }
    for (int last = 0; last < (1 << m); last++) {
        for (int cur = 0; cur < (1 << m); cur++)
            res = max(res, dp[last][cur][(n - 1) % 3]);
    }
    printf("%d\n", res);
    return 0;
}
```



### 15. POJ 1636 Prison rearrengement 🆗

- **代码**

```c++
//Memory: 764k
//Time:   94ms
//Result: Accepted
#include <cstdio>
#include <cstring>
const int MAXM = 200 + 5;

int n, m, r;
int a, b;
int G[MAXM << 1][MAXM << 1];
int S1[MAXM], S2[MAXM];
bool dp[MAXM >> 1][MAXM >> 1];
bool vis[MAXM << 1];
int cnt;

void initData() {
    cnt = 0;
    memset(G, 0, sizeof(G));
    memset(vis, 0, sizeof(vis));
    memset(dp, 0, sizeof(dp));
}

void dfs(int s) {
    vis[s] = true;
    s <= m ? S1[cnt]++ : S2[cnt]++;
    for (int i = 1; i <= (m << 1); i++)
        if (!vis[i] && G[s][i]) dfs(i);
}

int main() {
    // freopen("./DATA/in.txt", "r", stdin);
    scanf("%d", &n);
    while (n--) {
        initData();//初始化
        scanf("%d %d", &m, &r);
        for (int i = 1; i <= r; i++) {
            scanf("%d %d", &a, &b);
            //以 i + m 表示第二个监狱中编号为 i 的囚犯
            G[a][b + m] = G[b + m][a] = 1;
        }
        for (int i = 1; i <= (m << 1); i++) {
            if (!vis[i]) {
                S1[cnt] = S2[cnt] = 0;
                dfs(i), cnt++;
            }
        }
        dp[0][0] = true;
        for (int i = 0; i < cnt; i++) {
            for (int j = m >> 1; j >= S1[i]; j--) {
                for (int k = m >> 1; k >= S2[i]; k--)
                    if (dp[j - S1[i]][k - S2[i]]) dp[j][k] = true;
            }
        }
        int res = m >> 1;
        for (int i = m >> 1; i >= 0; i--) {
            if (dp[i][i]) {
                res = i;
                break;
            }
        }
        printf("%d\n", res);
    }
    return 0;
}
```



### 16. POJ 2228 Naptime 🆗

- **代码**

```c++
#include <algorithm>
#include <cstdio>
#include <cstring>
using namespace std;
const int maxn = 3830 + 5;

enum { Asleep, Awake };

int N, B;
int U[maxn];
int dp[2][maxn][2];//dp[i][j][?]: 在第 i 个时间段时已经休息了 j 个小时，且第 i 个时间段睡觉（Asleep） / 清醒（Awake）
int res;

void solve() {
    for (int i = 2; i <= N; i++) {
        for (int j = 0; j <= B; j++) {
            dp[i & 1][j][Awake] = max(dp[(i - 1) & 1][j][Asleep], dp[(i - 1) & 1][j][Awake]);
            if (j) dp[i & 1][j][Asleep] = max(dp[(i - 1) & 1][j - 1][Asleep] + U[i], dp[(i - 1) & 1][j - 1][Awake]);
        }
    }
}

int main() {
    scanf("%d %d", &N, &B);
    for (int i = 1; i <= N; i++) scanf("%d", &U[i]);
    memset(dp, -0x3f, sizeof(dp));
    dp[1][0][Awake] = dp[1][1][Asleep] = 0;
    solve();
    res = max(dp[N & 1][B][Awake], dp[N & 1][B][Asleep]);
    memset(dp, -0x3f, sizeof(dp));
    dp[1][1][Asleep] = U[1];
    solve();
    res = max(res, dp[N & 1][B][Asleep]);
    printf("%d\n", res);
    return 0;
}
```



## 五、第五部分 贪心 🆗

### 17. POJ 1042 Gone Fishing 🆗

- **代码**

```c++
//Memory: 532k
//Time:   110ms
//Result: Accepted
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;
const int maxn = 30;

int n, h;
int t[maxn];

struct pond {
    int id, f, d;
    pond() = default;
    pond(int id, int f, int d) : id(id), f(f), d(d) {}
    bool operator<(const pond &p) const {
        if (f == p.f) return id > p.id;
        return f < p.f;
    }
};

pond fish[maxn];
int times[maxn][maxn];//记录每个湖的钓鱼时间

priority_queue<pond> hp;

inline void initData() {
    memset(times, 0, sizeof(times));
}

int main() {
    // freopen("./DATA/in.txt", "r", stdin);
    while (scanf("%d", &n) != EOF && n) {
        initData();
        scanf("%d", &h);
        h *= 12;
        for (int i = 1; i <= n; i++)
            scanf("%d", &fish[i].f), fish[i].id = i;
        for (int i = 1; i <= n; i++) scanf("%d", &fish[i].d);
        for (int i = 1; i <= n - 1; i++) scanf("%d", &t[i]);
        int res = 0, idx = 1;
        for (int i = 1; i <= n; i++) {
            while (!hp.empty()) hp.pop();
            int tc = 0;
            for (int j = 1; j < i; j++) tc += t[j];
            for (int j = 1; j <= i; j++) hp.push(fish[j]);
            int ans = 0, t = h - tc;
            for (int j = 1; j <= t; j++) {
                pond p = hp.top();
                hp.pop();
                ans += p.f, times[i][p.id] += 5;
                hp.push(pond(p.id, max(p.f - p.d, 0), p.d));
            }
            if (ans > res)
                res = ans, idx = i;
        }
        for (int i = 1; i < n; i++) printf("%d, ", times[idx][i]);
        printf("%d\n", times[idx][n]);
        printf("Number of fish expected: %d\n\n", res);
    }
    return 0;
}
```



### 18. POJ 1328 Radar Installation 🆗

- **代码**

```c++
#include <algorithm>
#include <cmath>
#include <cstdio>
#define SQR(x) ((x) * (x))
using namespace std;
const int maxn = 1000 + 5;

int n, d;
double x, y;
int Kase;

struct interval {
    double left, right;
    bool operator<(const interval &b) const {
        return left <= b.left;
    }
};

interval intervals[maxn];

int solve() {
    sort(intervals, intervals + n);
    int minPoint = 1;
    double border = intervals[0].right;
    for (int i = 1; i < n; i++) {
        if (intervals[i].left > border) {// 区间 i-1 与 区间 i 无交集
            minPoint++;
            border = intervals[i].right;
        } else if (intervals[i].right < border) {// 区间 i-1 在 区间 i 内部
            border = intervals[i].right;
        }// 区间 i-1 与 区间 i 相交
    }
    return minPoint;
}

int main() {
    while (scanf("%d %d", &n, &d) && n && d) {
        bool isSolvable = true;
        for (int i = 0; i < n; i++) {
            scanf("%lf %lf", &x, &y);
            if (y > d) isSolvable = false;
            double offset = sqrt(SQR(d) - SQR(y));
            intervals[i].left = x - offset;
            intervals[i].right = x + offset;
        }
        int cnt = (isSolvable ? solve() : -1);
        printf("Case %d: %d\n", ++Kase, cnt);
    }
    return 0;
}
```



### 19. POJ 3040 Allowance 🆗

- **代码**

```c++
//Memory: 116k
//Time:   610ms
//Result: Accepted
#include <algorithm>
#include <cstdio>
#define LL long long
using namespace std;
const int maxn = 20 + 5;

int n, res;
LL C;

struct coin {
    LL value, cnt;
    bool operator<(const coin &c) const {
        return value > c.value;
    }
};

coin a[maxn];

int main() {
    scanf("%d %lld", &n, &C);
    for (int i = 1; i <= n; i++) scanf("%lld %lld", &a[i].value, &a[i].cnt);
    sort(a + 1, a + 1 + n);
    int pos = 1;
    for (; pos <= n; pos++) {
        if (a[pos].value >= C) res += a[pos].cnt;
        else
            break;
    }
    while (true) {
        LL cur = C;
        for (int i = pos; i <= n; i++) {
            while (a[i].value <= cur && a[i].cnt > 0 && cur > 0) {
                cur -= a[i].value;
                a[i].cnt--;
            }
        }
        if (cur > 0) {
            for (int i = n; i >= pos; i--) {
                if (a[i].value >= cur && a[i].cnt > 0) {
                    cur -= a[i].value;
                    a[i].cnt--;
                    break;
                }
            }
        }
        if (cur > 0) break;
        res++;
    }
    printf("%d\n", res);
    return 0;
}
```



### 20. POJ 1700 Crossing River 🆗

- **代码**

```c++
#include <algorithm>
#include <cstdio>
using namespace std;
const int maxn = 1000 + 5;

int T, n;
int a[maxn];
int res;

int main() {
    scanf("%d", &T);
    while (T--) {
        scanf("%d", &n);
        for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
        sort(a + 1, a + 1 + n);
        int k = n;
        res = 0;
        while (k > 3) {
            res += min((a[1] << 1) + a[k] + a[k - 1], a[k] + a[1] + (a[2] << 1));
            k -= 2;
        }
        if (k == 3) res += a[1] + a[2] + a[3];
        else if (k == 1 || k == 2)
            res += a[k];
        printf("%d\n", res);
    }
    return 0;
}
```



### 选做 POJ 2586 Y2K Accounting Bug 🆗

- **代码**

```c++
//Memory: 96k
//Time:   0ms
//Result: Accepted
#include <cstdio>

int s, d, res;

int main() {
    // freopen("./DATA/in.txt", "r", stdin);
    while (scanf("%d %d", &s, &d) == 2) {
        res = 0;
        if (d > 4 * s)
            res = 10 * s - 2 * d;
        else if (2 * d > 3 * s)
            res = 8 * s - 4 * d;
        else if (3 * d > 2 * s)
            res = 6 * s - 6 * d;
        else if (4 * d > s)
            res = 3 * s - 9 * d;
        else
            res = -12 * d;
        res >= 0 ? printf("%d\n", res) : printf("Deficit\n");
    }
    return 0;
}
```



## 六、第六部分 最短路 + 差分 🆗

### 21. POJ 1860 Currency Exchange 🆗

- **代码**

```c++
//Memory: 120k
//Time:   16ms
//Result: Accepted
#include <cstdio>
const int MAXN = 100 + 5;

int n, m, s;
double V;

struct edge {
    int u, v;
    double r, c;
    edge(int u = 0, int v = 0, double r = 0, double c = 0) : u(u), v(v), r(r), c(c) {}
};

edge edges[MAXN << 1];
int edge_cnt;

void addEdge(int u, int v, double r1, double c1, double r2, double c2) {
    edges[edge_cnt++] = edge(u, v, r1, c1);
    edges[edge_cnt++] = edge(v, u, r2, c2);
}

double dist[MAXN];

bool BellmanFord(int s) {
    for (int i = 0; i < n; i++) dist[i] = 0;
    dist[s] = V;
    for (int k = 1, updated = 1; k < n && updated; k++) {
        updated = 0;
        for (int i = 0; i < edge_cnt; i++) {
            edge e = edges[i];
            if (dist[e.v] < (dist[e.u] - e.c) * e.r) {
                dist[e.v] = (dist[e.u] - e.c) * e.r;
                updated = 1;
            }
        }
    }
    for (int i = 0; i < edge_cnt; i++)
        if (dist[edges[i].v] < (dist[edges[i].u] - edges[i].c) * edges[i].r) return true;
    return false;
}

int a, b;
double rab, cab, rba, cba;

int main() {
    scanf("%d %d %d %lf", &n, &m, &s, &V);
    for (int i = 0; i < m; i++) {
        scanf("%d %d %lf %lf %lf %lf", &a, &b, &rab, &cab, &rba, &cba);
        addEdge(a, b, rab, cab, rba, cba);
    }
    printf("%s", BellmanFord(s) ? "YES" : "NO");
    return 0;
}
```



### 22. POJ 2387 Til the Cows Come Home 🆗

- **代码**

```c++
//Memory: 184k
//Time:   32ms
//Result: Accepted
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;

const int MAXN = 1000 + 5, MAXM = 2000 + 5, INF = 0x3f3f3f3f;

int n, m;
int u, v, w;

struct edge {
    int u, v, w, nxt;
    edge(int u = 0, int v = 0, int w = 0, int nxt = 0) : u(u), v(v), w(w), nxt(nxt) {}
} edges[MAXM << 1];

int head[MAXN], idx;

void addEdge(int u, int v, int w) {
    edges[idx] = edge(u, v, w, head[u]);
    head[u] = idx++;
    edges[idx] = edge(v, u, w, head[v]);
    head[v] = idx++;
}

int dist[MAXN];
bool inQueue[MAXN];
int cnt[MAXN];

bool SPFA(int s) {
    for (int i = 0; i <= n; i++)
        dist[i] = INF, inQueue[i] = false, cnt[i] = 0;
    dist[s] = 0, inQueue[s] = true;
    queue<int> q;
    q.push(s);
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        if (cnt[u] > n) return false;
        inQueue[u] = false;
        for (int i = head[u]; ~i; i = edges[i].nxt) {
            int v = edges[i].v, w = edges[i].w;
            if (dist[v] > dist[u] + w) {
                dist[v] = dist[u] + w;
                if (!inQueue[v]) {
                    q.push(v);
                    inQueue[v] = true;
                    cnt[v]++;
                }
            }
        }
    }
    return true;
}

int main() {
    scanf("%d %d", &m, &n);
    memset(head, -1, sizeof(head));
    for (int i = 0; i < m; i++) {
        scanf("%d %d %d", &u, &v, &w);
        addEdge(u, v, w);
    }
    SPFA(1);
    printf("%d\n", dist[n]);
    return 0;
}
```



### 23. POJ 1062 昂贵的聘礼 🆗

- **代码**

```c++
//Memory: 228k
//Time:   0ms
//Result: Accepted
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;
const int MAXN = 100 + 5, MAXM = 10000 + 5, INF = 0x3f3f3f3f;

int n, m;
int p, l, x;
int t, v;

int level[MAXN];

struct edge {
    int v, w, nxt;
    edge(int v = 0, int w = 0, int nxt = 0) : v(v), w(w), nxt(nxt) {}
    bool operator<(const edge &e) const { return w > e.w; }
};

edge edges[MAXM];
int head[MAXN], edge_cnt;

void addEdge(int u, int v, int w) {
    edges[edge_cnt] = edge(v, w, head[u]);
    head[u] = edge_cnt++;
}

bool inQueue[MAXN];
int dist[MAXN];

bool SPFA(int s, int left, int right) {
    memset(dist, 0x3f, sizeof(dist));
    memset(inQueue, 0, sizeof(inQueue));
    dist[s] = 0, inQueue[s] = true;
    queue<int> q;
    q.push(s);
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        inQueue[u] = false;
        for (int i = head[u]; ~i; i = edges[i].nxt) {
            int v = edges[i].v, w = edges[i].w;
            if (level[v] < left || level[v] > right) continue;
            if (dist[v] > dist[u] + w) {
                dist[v] = dist[u] + w;
                if (!inQueue[v]) {
                    q.push(v);
                    inQueue[v] = true;
                }
            }
        }
    }
    return true;
}

int main() {
    // freopen("./DATA/in.txt", "r", stdin);
    scanf("%d %d", &m, &n);
    memset(head, -1, sizeof(head));
    for (int i = 1; i <= n; i++) {
        scanf("%d %d %d", &p, &l, &x);
        level[i] = l;
        addEdge(0, i, p);
        for (int j = 1; j <= x; j++) {
            scanf("%d %d", &t, &v);
            addEdge(t, i, v);
        }
    }
    int res = INF;
    for (int i = level[1] - m; i <= level[1]; i++) {
        SPFA(0, i, i + m);
        res = min(res, dist[1]);
    }
    printf("%d\n", res);
    return 0;
}
```



### 24. POJ 3660 Cow Contest 🆗

- **代码**

```c++
//Memory: 108k
//Time:   32ms
//Result: Accepted
#include <cstdio>
const int MAXN = 100 + 5;

int n, m;
int a, b;
bool d[MAXN][MAXN];

void Floyd() {
    for (int k = 1; k <= n; k++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++)
                d[i][j] = d[i][j] | d[i][k] & d[k][j];
        }
    }
}

int main() {
    // freopen("./DATA/in.txt", "r", stdin);
    scanf("%d %d", &n, &m);
    for (int i = 1; i <= m; i++) {
        scanf("%d %d", &a, &b);
        d[a][b] = true;
    }
    Floyd();
    int res = 0;
    for (int i = 1; i <= n; i++) {
        int flag = 1;
        for (int j = 1; j <= n; j++) {
            if (i == j) continue;
            if (!d[i][j] && !d[j][i]) {
                flag = 0;
                break;
            }
        }
        res += flag;
    }
    printf("%d\n", res);
    return 0;
}
```



### 25. POJ 1201 Intervals 🆗

- **代码**

```c++
//Memory: 3172k
//Time:   360ms
//Result: Accepted
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;
const int MAXN = 50000 + 5, INF = 0x3f3f3f3f;

int n, a, b, c;

struct edge {
    int v, w, nxt;
    edge(int v = 0, int w = 0, int nxt = 0) : v(v), w(w), nxt(nxt) {}
};

edge edges[MAXN << 2];
int head[MAXN], edge_cnt;

void addEdge(int u, int v, int w) {
    edges[edge_cnt] = edge(v, w, head[u]);
    head[u] = edge_cnt++;
}

int dist[MAXN], cnt[MAXN];
bool inQueue[MAXN];

bool SPFA(int s) {
    memset(dist, -0x3f, sizeof(dist));
    dist[s] = 0, inQueue[s] = true;
    queue<int> q;
    q.push(s);
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        if (cnt[u] > n) return false;
        inQueue[u] = false;
        for (int i = head[u]; ~i; i = edges[i].nxt) {
            int v = edges[i].v, w = edges[i].w;
            if (dist[v] < dist[u] + w) {
                dist[v] = dist[u] + w;
                if (!inQueue[v]) {
                    q.push(v);
                    inQueue[v] = true;
                    cnt[v]++;
                }
            }
        }
    }
    return true;
}

int main() {
    // freopen("./DATA/in.txt", "r", stdin);
    scanf("%d", &n);
    memset(head, -1, sizeof(head));
    for (int i = 1; i <= n; i++) {
        scanf("%d %d %d", &a, &b, &c);
        addEdge(a, b + 1, c);//整体加一
    }
    for (int i = 1; i <= 50001; i++)
        addEdge(i - 1, i, 0), addEdge(i, i - 1, -1);
    SPFA(0);
    printf("%d\n", dist[50001]);
    return 0;
}
```



### 选做 POJ 3169 Layout 🆗 :small_orange_diamond:

- **代码**

```c++
//Memory: 1156k
//Time:   63ms
//Result: Accepted
#include <cstdio>
#include <cstring>
#include <queue>
#define LL long long
using namespace std;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 10;

int n, L, D;
int x, y, w;
int s;

struct node {
    int to, w, nxt;
    node() {}
    node(int to, int w, int nxt) : to(to), w(w), nxt(nxt) {}
};

node edges[MAXN];
int head[MAXN], cnt;

void addEdge(int u, int v, int w) {
    cnt++;
    edges[cnt] = node(v, w, head[u]);
    head[u] = cnt;
}

bool inQueue[MAXN];
int vis[MAXN], dis[MAXN];

int SPFA(int s) {
    queue<int> Q;
    memset(dis, 0x3f, sizeof(dis));
    memset(vis, 0, sizeof(vis));
    memset(inQueue, 0, sizeof(inQueue));
    dis[s] = 0;
    Q.push(s), inQueue[s] = true;
    while (!Q.empty()) {
        int u = Q.front();
        Q.pop(), inQueue[u] = false;
        for (int e = head[u]; e != 0; e = edges[e].nxt) {
            int v = edges[e].to;
            if (dis[v] > dis[u] + edges[e].w) {
                dis[v] = dis[u] + edges[e].w;
                if (!inQueue[v]) {
                    Q.push(v), inQueue[v] = true;
                    if (++vis[v] > n) return -1;
                }
            }
        }
    }
    return dis[n];
}

int main() {
    // freopen("./DATA/in.txt", "r", stdin);
    scanf("%d %d %d", &n, &L, &D);
    for (int i = 1; i <= L; i++) {
        scanf("%d %d %d", &x, &y, &w);
        addEdge(x, y, w);
    }
    for (int i = 1; i <= D; i++) {
        scanf("%d %d %d", &x, &y, &w);
        addEdge(y, x, -w);
    }
    for (int i = 1; i <= n; i++) addEdge(0, i, 0);
    for (int i = 1; i < n; i++) addEdge(i + 1, i, 0);
    if (SPFA(0) == -1) printf("-1\n");
    else {
        if (SPFA(1) == -1) printf("-1\n");
        else if (dis[n] == INF)
            printf("-2\n");
        else
            printf("%d\n", dis[n]);
    }
    return 0;
}
```



## 七、第七部分 搜索 🆗

### 26. POJ 1324 Holedox Moving 🆗 🆗 :small_orange_diamond:

- **代码（优化前）**

```c++
//Memory: 9628k
//Time:   1219ms
//Result: Accepted
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;
const int MAXN = 20 + 1;
const int offset[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

enum LAIR { VACANT,
            STONE };

int R, C, L, K;

int lair[MAXN][MAXN];
bool vis[MAXN][MAXN][1 << 14];

struct Body {
    int x, y;
} snake[10];

struct State {
    int x, y, step, state, f;
    State(int x, int y, int step, int state, int f) : x(x), y(y), step(step), state(state), f(f) {}
    bool operator<(const State &s) const { return f > s.f; }
};

inline int Manhatten(int x, int y) {
    return abs(x - 1) + abs(y - 1);
}

//将蛇身体所在的位置设为不可进入
void setStone() {
    for (int i = 1; i < L; i++)
        lair[snake[i].x][snake[i].y] = STONE;
}

//还原蛇身体所在位置的可进入性
void clearStone() {
    for (int i = 1; i < L; i++)
        lair[snake[i].x][snake[i].y] = VACANT;
}

//根据蛇现在的姿态确定状态参数 state
int getState(int x, int y) {
    int state = 0;
    for (int i = 1; i < L; i++) {
        state <<= 2;
        if (snake[i].x > snake[i - 1].x)
            state |= 0;//up
        else if (snake[i].x < snake[i - 1].x)
            state |= 1;//down
        else if (snake[i].y > snake[i - 1].y)
            state |= 2;//left
        else if (snake[i].y < snake[i - 1].y)
            state |= 3;//right;
    }
    return state;
}

//根据状态参数 state 还原蛇的姿态
void setBody(int x, int y, int state) {
    const int MASK = 3;
    snake[0].x = x, snake[0].y = y;
    for (int i = 1; i < L; i++) {
        int val = (state >> ((L - i - 1) << 1)) & MASK;
        if (val == 0) {
            snake[i].x = snake[i - 1].x + 1;
            snake[i].y = snake[i - 1].y;
        } else if (val == 1) {
            snake[i].x = snake[i - 1].x - 1;
            snake[i].y = snake[i - 1].y;
        } else if (val == 2) {
            snake[i].x = snake[i - 1].x;
            snake[i].y = snake[i - 1].y + 1;
        } else if (val == 3) {
            snake[i].x = snake[i - 1].x;
            snake[i].y = snake[i - 1].y - 1;
        }
    }
}

//是否可以进入
bool isAvailable(int x, int y) {
    if (x < 1 || x > R || y < 1 || y > C || lair[x][y] == STONE)
        return false;
    return true;
}

int A_star() {
    priority_queue<State> q;
    int x = snake[0].x, y = snake[0].y;
    int state = getState(x, y);
    int f = Manhatten(x, y);
    q.push(State(x, y, 0, state, f));
    vis[x][y][state] = true;
    while (!q.empty()) {
        State u = q.top();
        q.pop();
        if (u.x == 1 && u.y == 1) return u.step;
        setBody(u.x, u.y, u.state);
        setStone();
        for (int k = 0; k < 4; k++) {
            x = u.x + offset[k][0];
            y = u.y + offset[k][1];
            state = (L < 2) ? 0 : (u.state >> 2) | (k << ((L - 2) << 1));
            if (isAvailable(x, y) && !vis[x][y][state]) {
                vis[x][y][state] = true;
                f = u.step + 1 + Manhatten(x, y);
                q.push(State(x, y, u.step + 1, state, f));
            }
        }
        clearStone();
    }
    return -1;
}

int Kases = 0;

int main() {
    // freopen("./DATA/in.txt", "r", stdin);
    while (scanf("%d %d %d", &R, &C, &L) && R && C && L) {
        memset(lair, 0, sizeof(lair));
        memset(vis, 0, sizeof(vis));
        for (int i = 0; i < L; i++)
            scanf("%d %d", &snake[i].x, &snake[i].y);
        scanf("%d", &K);
        for (int i = 0, x, y; i < K; i++) {
            scanf("%d %d", &x, &y);
            lair[x][y] = STONE;
        }
        printf("Case %d: %d\n", ++Kases, A_star());
    }
    return 0;
}
```

- **代码（优化后）**

```c++
//Memory: 7828k
//Time:   391ms
//Result: Accepted
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;
const int MAXN = 20 + 1;
const int offset[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

enum LAIR { VACANT,
            STONE };

int R, C, L, K;

int lair[MAXN][MAXN];
bool vis[MAXN][MAXN][1 << 14];

struct Body {
    int x, y;
} snake[10];

struct State {
    int x, y, step, state, f;
    State(int x, int y, int step, int state, int f) : x(x), y(y), step(step), state(state), f(f) {}
    bool operator<(const State &s) const { return f > s.f; }
};

//估计函数 f 采用曼哈顿距离
inline int Manhatten(int x, int y) {
    return abs(x - 1) + abs(y - 1);
}

//将蛇身体所在的位置设为不可进入
void setStone() {
    for (int i = 1; i < L; i++)
        lair[snake[i].x][snake[i].y] = STONE;
}

//还原蛇身体所在位置的可进入性
void clearStone() {
    for (int i = 1; i < L; i++)
        lair[snake[i].x][snake[i].y] = VACANT;
}

//根据蛇现在的姿态确定状态参数 state
int getState(int x, int y) {
    int state = 0;
    for (int i = 1; i < L; i++) {
        state <<= 2;
        if (snake[i].x > snake[i - 1].x)
            state |= 0;//up
        else if (snake[i].x < snake[i - 1].x)
            state |= 1;//down
        else if (snake[i].y > snake[i - 1].y)
            state |= 2;//left
        else if (snake[i].y < snake[i - 1].y)
            state |= 3;//right;
    }
    return state;
}

//根据状态参数 state 还原蛇的姿态
void setBody(int x, int y, int state) {
    const int MASK = 3;
    snake[0].x = x, snake[0].y = y;
    for (int i = 1; i < L; i++) {
        int val = (state >> ((L - i - 1) << 1)) & MASK;
        if (val == 0) {
            snake[i].x = snake[i - 1].x + 1;
            snake[i].y = snake[i - 1].y;
        } else if (val == 1) {
            snake[i].x = snake[i - 1].x - 1;
            snake[i].y = snake[i - 1].y;
        } else if (val == 2) {
            snake[i].x = snake[i - 1].x;
            snake[i].y = snake[i - 1].y + 1;
        } else if (val == 3) {
            snake[i].x = snake[i - 1].x;
            snake[i].y = snake[i - 1].y - 1;
        }
    }
}

//是否可以进入
bool isAvailable(int x, int y) {
    if (x < 1 || x > R || y < 1 || y > C || lair[x][y] == STONE)
        return false;
    return true;
}

int A_star() {
    priority_queue<State> q;
    int x = snake[0].x, y = snake[0].y;
    int state = getState(x, y);
    int f = Manhatten(x, y);
    q.push(State(x, y, 0, state, f));
    vis[x][y][state] = true;
    while (!q.empty()) {
        State u = q.top();
        q.pop();
        if (u.x == 1 && u.y == 1) return u.step;
        setBody(u.x, u.y, u.state);
        setStone();
        for (int k = 0; k < 4; k++) {
            x = u.x + offset[k][0];
            y = u.y + offset[k][1];
            state = (L < 2) ? 0 : (u.state >> 2) | (k << ((L - 2) << 1));
            if (isAvailable(x, y) && !vis[x][y][state]) {
                vis[x][y][state] = true;
                f = u.step + 1 + Manhatten(x, y);
                q.push(State(x, y, u.step + 1, state, f));
            }
        }
        clearStone();
    }
    return -1;
}

int BFS() {
    bool visited[MAXN][MAXN];
    memset(visited, 0, sizeof(visited));
    priority_queue<State> q;
    int x = snake[0].x;
    int y = snake[0].y;
    int f = Manhatten(x, y);
    q.push(State(x, y, 0, 0, f));
    visited[x][y] = true;
    while (!q.empty()) {
        State u = q.top();
        q.pop();
        if (u.x == 1 && u.y == 1) return u.step;
        for (int k = 0; k < 4; k++) {
            x = u.x + offset[k][0];
            y = u.y + offset[k][1];
            if (isAvailable(x, y) && !visited[x][y]) {
                visited[x][y] = true;
                f = u.step + 1 + Manhatten(x, y);
                q.push(State(x, y, u.step + 1, 0, f));
            }
        }
    }
    return -1;
}

int Kases = 0, res;

int main() {
    // freopen("./DATA/in.txt", "r", stdin);
    while (scanf("%d %d %d", &R, &C, &L) && R && C && L) {
        memset(lair, 0, sizeof(lair));
        memset(vis, 0, sizeof(vis));
        for (int i = 0; i < L; i++)
            scanf("%d %d", &snake[i].x, &snake[i].y);
        scanf("%d", &K);
        for (int i = 0, x, y; i < K; i++) {
            scanf("%d %d", &x, &y);
            lair[x][y] = STONE;
        }
        int minStep = BFS();
        setStone();
        int maxStep = BFS();
        clearStone();
        if (minStep == -1) res = -1;
        else if (minStep == maxStep)
            res = minStep;
        else
            res = A_star();
        printf("Case %d: %d\n", ++Kases, res);
    }
    return 0;
}
```



### 27. POJ 1084 Square Destroyer 🆗

- **代码**

```c++
//Memory: 140k
//Time:   0ms
//Result: Accepted
#include <cstdio>
#include <cstring>
#include <vector>
using namespace std;
const int MAXN = 60 + 5;

int T, edge, n, cnt;
bool isDestroyed[MAXN];
vector<int> squares[MAXN];

static bool backup[MAXN];

void addSquare(int R, int C, int L) {
    int d = n << 1 | 1;
    squares[cnt].clear();
    for (int i = 0; i < L; i++) {
        squares[cnt].push_back(1 + R * d + C + i);
        squares[cnt].push_back(1 + (R + L) * d + C + i);
        squares[cnt].push_back(1 + n + R * d + C + i * d);
        squares[cnt].push_back(1 + n + R * d + C + i * d + L);
    }
    cnt++;
}

bool isFull(vector<int> &s) {
    for (int i = 0; i < s.size(); i++)
        if (isDestroyed[s[i]]) return false;
    return true;
}

int evaluate() {
    memcpy(backup, isDestroyed, sizeof(isDestroyed));
    int value = 0;
    for (int i = 0; i < cnt; i++) {
        if (isFull(squares[i])) {
            value++;
            for (int j = 0; j < squares[i].size(); j++)
                isDestroyed[squares[i][j]] = true;
        }
    }
    memcpy(isDestroyed, backup, sizeof(isDestroyed));
    return value;
}

bool dfs(int nowDepth, int maxDepth) {
    if (nowDepth + evaluate() > maxDepth) return false;
    for (int i = 0; i < cnt; i++) {
        if (isFull(squares[i])) {
            for (int j = 0; j < squares[i].size(); j++) {
                isDestroyed[squares[i][j]] = true;
                if (dfs(nowDepth + 1, maxDepth)) return true;
                isDestroyed[squares[i][j]] = false;
            }
            return false;
        }
    }
    return true;
}

int IDA_star() {
    int maxDepth = 0;
    while (!dfs(0, maxDepth)) maxDepth++;
    return maxDepth;
}

int main() {
    // freopen("./DATA/in.txt", "r", stdin);
    scanf("%d", &T);
    while (T--) {
        scanf("%d", &n);
        cnt = 0;
        memset(isDestroyed, false, sizeof(isDestroyed));
        for (int l = 1; l <= n; l++) {
            for (int r = 0; r <= n - l; r++) {
                for (int c = 0; c <= n - l; c++)
                    addSquare(r, c, l);
            }
        }
        scanf("%d", &edge);
        while (edge--) {
            int x;
            scanf("%d", &x);
            isDestroyed[x] = true;
        }
        printf("%d\n", IDA_star());
    }
    return 0;
}
```



### 28. POJ 2449 Remmarguts’ Date 🆗

- **解析**

  K 短路问题，注意特殊情况的判断。

- **代码**

```c++
//Memory: 7360k
//Time:   282ms
//Result: Accepted
#include <cstdio>
#include <cstring>
#include <queue>
// #include <tuple>
#include <vector>
using namespace std;
const int MAXV = 1000 + 5, MAXE = 100000 + 5, INF = 0x3f3f3f3f;

int n, m;
int head[MAXV], cnt;
int dist[MAXV];
bool vis[MAXV];

struct edge {
    int v, w, nxt;
    edge(int v = 0, int w = 0, int nxt = 0) : v(v), w(w), nxt(nxt) {}
} edges[MAXE];

struct state {
    int u, walked;
    state(int u = 0, int walked = 0) : u(u), walked(walked) {}
    bool operator<(const state &s) const { return walked > s.walked; }
};

void clearEdge() {
    cnt = 0;
    memset(head, -1, sizeof(head));
}

void addEdge(int u, int v, int w) {
    edges[cnt] = edge(v, w, head[u]);
    head[u] = cnt++;
}

struct tmp {
    int a, b, c;
    tmp(int a = 0, int b = 0, int c = 0) : a(a), b(b), c(c) {}
};

vector<tmp> data;

priority_queue<state> q;

int KSP(vector<tmp> &data, int s, int t, int K) {
    clearEdge();
    // for (tmp d: data) addEdge(d.b, d.a, d.c);
    for (int i = 0; i < data.size(); i++)
        addEdge(data[i].b, data[i].a, data[i].c);
    for (int i = 0; i < n; i++) dist[i] = INF, vis[i] = false;
    int u = t;
    dist[u] = 0;
    while (!vis[u]) {
        vis[u] = true;
        for (int i = head[u]; ~i; i = edges[i].nxt) {
            edge e = edges[i];
            if (!vis[e.v] && dist[e.v] > dist[u] + e.w)
                dist[e.v] = dist[u] + e.w;
        }
        int least = INF;
        for (int i = 0; i < n; i++) {
            if (!vis[i] && dist[i] < least)
                least = dist[i], u = i;
        }
    }
    clearEdge();
    // for (tmp d: data) addEdge(d.a, d.b, d.c);
    for (int i = 0; i < data.size(); i++)
        addEdge(data[i].a, data[i].b, data[i].c);
    while (!q.empty()) q.pop();
    q.push(state(s, dist[s]));
    while (!q.empty()) {
        state st = q.top();
        q.pop();
        int walked = st.walked - dist[st.u];
        if (st.u == t) {
            if (!(--K)) return walked;
        }
        for (int i = head[st.u]; ~i; i = edges[i].nxt) {
            q.push(state(edges[i].v, walked + edges[i].w + dist[edges[i].v]));
        }
    }
    return -1;
}

int s, t, k;
// vector<tuple<int, int, int>> data;

int main() {
    // freopen("./DATA/in.txt", "r", stdin);
    scanf("%d %d", &n, &m);
    for (int i = 0, u, v, w; i < m; i++) {
        scanf("%d %d %d", &u, &v, &w);
        u--, v--;
        data.push_back(tmp(u, v, w));
    }
    scanf("%d %d %d", &s, &t, &k);
    s--, t--;
    if (s == t) k++;//注意！！！
    printf("%d\n", KSP(data, s, t, k));
    return 0;
}
```



### 29. POJ 1475 Pushing Boxes 🆗

- **代码**

```c++
//Memory: 124k
//Time:   94ms
//Result: Accepted
#include <cstdio>
#include <cstring>
#include <queue>
#include <string>
using namespace std;
const int MAXN = 20 + 1;
const int offset[4][2] = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};
const char moveOfPerson[4] = {'n', 's', 'e', 'w'};
const char moveOfBox[4] = {'N', 'S', 'E', 'W'};

bool visP[MAXN][MAXN], visB[MAXN][MAXN];
char maze[MAXN][MAXN];

int sx, sy, ex, ey, bx, by, r, c;

struct status {//对应箱子
    int px, py;
    int bx, by;
    string path;
    status(int px = 0, int py = 0, int bx = 0, int by = 0, string path = "") : px(px), py(py), bx(bx), by(by), path(path) {}
} p, q;

struct node {//对应人
    int x, y;
    string path;
    node(int x = 0, int y = 0, string path = "") : x(x), y(y), path(path) {}
} P, Q;

//判断是否越界
bool isAvailable(const int x, const int y) {
    if (x < 0 || x >= r || y < 0 || y >= c) return false;
    return true;
}

bool bfs2(int st_x, int st_y, int ed_x, int ed_y) {
    memset(visP, 0, sizeof(visP));
    P.x = st_x, P.y = st_y; //人的初始位置坐标
    P.path = "";            //记录路径
    visP[P.x][P.y] = true;  //标记该点
    visP[p.bx][p.by] = true;//箱子的起始位置对人而言相当于障碍物
    queue<node> que;
    que.push(P);
    while (!que.empty()) {
        P = que.front(), que.pop();
        if (P.x == ed_x && P.y == ed_y)//到达可以推箱子的位置
            return true;
        for (int k = 0; k < 4; k++) {
            int dx = P.x + offset[k][0];
            int dy = P.y + offset[k][1];
            if (isAvailable(dx, dy) && maze[dx][dy] != '#' && !visP[dx][dy]) {
                visP[dx][dy] = true;//标记该点
                Q.x = dx, Q.y = dy, Q.path = P.path + moveOfPerson[k];
                que.push(Q);
            }
        }
    }
    return false;
}

bool bfs1() {
    memset(visB, 0, sizeof(visB));
    p.px = sx, p.py = sy;//人的初始位置坐标
    p.bx = bx, p.by = by;//箱子初始位置坐标
    p.path = "";         //记录路径
    visB[bx][by] = true;
    queue<status> que;
    que.push(p);
    while (!que.empty()) {
        p = que.front(), que.pop();
        for (int k = 0; k < 4; k++) {
            //箱子移动后的位置坐标
            int nx = p.bx + offset[k][0];
            int ny = p.by + offset[k][1];
            //人到达可以推箱子的位置坐标
            int tx = p.bx - offset[k][0];
            int ty = p.by - offset[k][1];
            if (isAvailable(nx, ny) && maze[nx][ny] != '#' && isAvailable(tx, ty) && maze[tx][ty] != '#' && !visB[nx][ny]) {
                if (bfs2(p.px, p.py, tx, ty)) {//将人的起始位置和能推箱子的位置带入进行人的 BFS
                    visB[nx][ny] = true;
                    q.bx = nx, q.by = ny, q.px = p.bx, q.py = p.by;
                    q.path = p.path + P.path + moveOfBox[k];
                    if (nx == ex && ny == ey)
                        return true;
                    que.push(q);
                }
            }
        }
    }
    return false;
}

int Kase;

int main() {
    // freopen("./DATA/in.txt", "r", stdin);
    while (scanf("%d %d", &r, &c) && r && c) {
        for (int i = 0; i < r; i++) {
            scanf("%s", maze[i]);
            for (int j = 0; j < c; j++) {
                if (maze[i][j] == 'S')//人的起始位置
                    sx = i, sy = j;
                else if (maze[i][j] == 'B')//箱子的起始位置
                    bx = i, by = j;
                else if (maze[i][j] == 'T')//箱子的终止位置
                    ex = i, ey = j;
            }
        }
        printf("Maze #%d\n", ++Kase);
        if (bfs1())//箱子 bfs
            printf("%s\n", q.path.c_str());
        else
            printf("Impossible.\n");
        putchar('\n');
    }
    return 0;
}
```



### 30. POJ 1077 Eight 🆗

- **代码**

```c++
#include <algorithm>
#include <iostream>
#include <map>
#include <queue>
#include <string>
using namespace std;
typedef pair<int, string> PIS;
const int dir[] = {-1, 0, 1, 0, -1};
const char opt[] = {'u', 'r', 'd', 'l'};

string START, s, c;

inline int idx(int x, int y) {
    return 3 * x + y;
}

inline int Manhattan(int a, int b) {
    return abs(a / 3 - b / 3) + abs(a % 3 + b % 3);
}

int findX(string s) {
    for (int i = 0; i < 9; i++)
        if (s[i] == 'x') return i;
    return -1;
}

//估价函数
int f(string s) {
    int res = 0;
    for (int i = 0; i < 9; i++) {
        if (s[i] != 'x') {
            int t = s[i] - '1';
            res += Manhattan(i, t);
        }
    }
    return res;
}

string AStar() {
    priority_queue<PIS, vector<PIS>, greater<PIS>> q;
    map<string, int> dis;
    map<string, bool> vis;
    map<string, pair<string, char>> pre;
    q.push({f(START), START});
    dis[START] = 0;
    while (!q.empty()) {
        PIS t = q.top();
        q.pop();
        string status = t.second;
        if (status == "12345678x") break;
        if (vis[status]) continue;
        vis[status] = true;
        int pos = findX(status);
        int x = pos / 3, y = pos % 3;
        int step = dis[status];
        string raw = status;
        for (int k = 0; k < 4; k++) {
            int dx = x + dir[k], dy = y + dir[k + 1];
            if (dx < 0 || dx >= 3 || dy < 0 || dy >= 3) continue;
            status = raw;
            swap(status[idx(x, y)], status[idx(dx, dy)]);
            if (!dis.count(status) || dis[status] > step + 1) {
                dis[status] = step + 1;
                pre[status] = {raw, opt[k]};
                q.push({f(status) + dis[status], status});
            }
        }
    }
    string res, END = "12345678x";
    while (START != END) {
        res += pre[END].second;
        END = pre[END].first;
    }
    reverse(res.begin(), res.end());
    return res;
}

int main() {
    // freopen("./DATA/in.txt", "r", stdin);
    for (int i = 0; i < 9; i++) {
        cin >> c, START += c;
        if (c != "x") s += c;
    }
    int sum = 0;
    for (int i = 0; i < 8; i++) {
        for (int j = i + 1; j < 8; j++) {
            if (s[i] > s[j]) sum++;
        }
    }
    if (sum & 1) cout << "unsolvable" << endl;
    else
        cout << AStar() << endl;
    return 0;
}
```



### 选做 POJ 1184 聪明的打字员 🆗

- **解析**

  无话可说……剪枝策略需要非常严格，每次操作消耗时间也要尽量短。

- **代码**

```c++
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;
const int MAXN = 1e6 + 5;

int flag[MAXN][7][2];

struct node {
    int step, num, pos, kind;//使用步数，当前数字，光标位置，搜索种类
    node() {}
    node(int step, int num, int pos, int kind) : step(step), num(num), pos(pos), kind(kind) {}
};

int s[10];
int pre[7] = {1000000, 100000, 10000, 1000, 100, 10, 1};

inline int Cal(int num, int pos, int x) {
    int tmp = (num / pre[pos]) % 10 + x;
    if (tmp >= 0 && tmp <= 9)
        return num / pre[pos - 1] * pre[pos - 1] + tmp * pre[pos] + num % pre[pos];
    return num;
}

inline int Swap(int num, int pos, int target) {
    int t1 = (num / pre[pos]) % 10;
    int t2 = (num / pre[target]) % 10;
    if (t1 == t2) return num;
    num = num / pre[pos - 1] * pre[pos - 1] + t2 * pre[pos] + num % pre[pos];
    num = num / pre[target - 1] * pre[target - 1] + t1 * pre[target] + num % pre[target];
    return num;
}

inline bool Judge(int pos, int a, int b) {
    return ((a / pre[pos]) % 10 == (b / pre[pos]) % 10);
}

queue<node> q;

int D_BFS(int a, int b) {
    memset(flag, -1, sizeof(flag));
    q.push(node(0, a, 1, 0));
    flag[a][1][0] = 0;
    for (int i = 1; i <= 6; i++)
        flag[b][i][1] = 0, q.push(node(0, b, i, 1));
    while (!q.empty()) {
        node nxt, cur = q.front();
        q.pop();
        if (~flag[cur.num][cur.pos][cur.kind ^ 1])
            return flag[cur.num][cur.pos][cur.kind ^ 1] + cur.step;
        nxt.kind = cur.kind, nxt.num = cur.num, nxt.step = cur.step + 1;
        //left 操作
        if (cur.pos > 1 && (cur.pos < 2 || cur.pos > 5 || Judge(cur.pos, cur.num, cur.kind == 0 ? b : a))) {
            nxt.pos = cur.pos - 1;
            if (!~flag[nxt.num][nxt.pos][nxt.kind])
                flag[nxt.num][nxt.pos][nxt.kind] = nxt.step, q.push(nxt);
        }
        //right 操作
        if (cur.pos < 6 && (cur.pos < 2 || cur.pos > 5 || Judge(cur.pos, cur.num, cur.kind == 0 ? b : a))) {
            nxt.pos = cur.pos + 1;
            if (!~flag[nxt.num][nxt.pos][nxt.kind])
                flag[nxt.num][nxt.pos][nxt.kind] = nxt.step, q.push(nxt);
        }
        //up 操作
        nxt.num = Cal(cur.num, cur.pos, 1);
        nxt.pos = cur.pos;
        if (!~flag[nxt.num][nxt.pos][nxt.kind])
            flag[nxt.num][nxt.pos][nxt.kind] = nxt.step, q.push(nxt);
        //down 操作
        nxt.num = Cal(cur.num, cur.pos, -1);
        if (!~flag[nxt.num][nxt.pos][nxt.kind])
            flag[nxt.num][nxt.pos][nxt.kind] = nxt.step, q.push(nxt);
        //swap0 操作
        if (cur.pos != 1) {
            nxt.num = Swap(cur.num, cur.pos, 1);
            if (!~flag[nxt.num][nxt.pos][nxt.kind])
                flag[nxt.num][nxt.pos][nxt.kind] = nxt.step, q.push(nxt);
        }
        //swap1 操作
        if (cur.pos != 6) {
            nxt.num = Swap(cur.num, cur.pos, 6);
            if (!~flag[nxt.num][nxt.pos][nxt.kind])
                flag[nxt.num][nxt.pos][nxt.kind] = nxt.step, q.push(nxt);
        }
    }
    return 0;
}
int a, b;

int main() {
    // freopen("./DATA/in.txt", "r", stdin);
    scanf("%d %d", &a, &b);
    printf("%d\n", D_BFS(a, b));
    return 0;
}
```

